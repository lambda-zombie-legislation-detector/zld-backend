# Set our server to be ENV_VAR PORT or 2019
server.port=${PORT:2020}

# Actuator stuff
management.endpoints.web.exposure.include=*
management.endpoint.health.show-details=always

#Custom error message
server.error.whitelabel.enabled=true

# Let us control spring logging
logging.level.web=DEBUG

#Feature that determines what happens when no accessors are found for a type
#(and there are no annotations to indicate it is meant to be serialized).
spring.jackson.serialization.FAIL_ON_EMPTY_BEANS=false

##drop n create table again, good for testing, comment this in production
spring.jpa.hibernate.ddl-auto=create-drop
#spring.datasource.initialization-mode=always

# For PostgreSQL - on local machine uses hard coded, on deploy use env
spring.datasource.jdbc-url=${SPRING_DATASOURCE_URL:jdbc:postgresql://localhost:5432/legicycle}
spring.datasource.username=${SPRING_DATASOURCE_USERNAME:legicycle}
spring.datasource.password=${SPRING_DATASOURCE_PASSWORD:legicycle}
# suggested by heroku for postgres
spring.datasource.driverClassName=org.postgresql.Driver
spring.datasource.maxActive=10
spring.datasource.maxIdle=5
spring.datasource.minIdle=2
spring.datasource.initialSize=5
spring.datasource.removeAbandoned=true

#these are grabbed by the datasource config fro db1
spring.jpa.properties.hibernate.jdbc.lob.non_contextual_creation=true
spring.datasource.ddl=${SPRING_DATASOURCE_DDL:create-drop}
spring.datasource.dialect=org.hibernate.dialect.PostgreSQLDialect


#Set up second-datasource;
# url and jdbc-url are the same
spring.second-datasource.jdbc-url=jdbc:postgresql://localhost:5432/lambdaschool
spring.second-datasource.username=legicycle
spring.second-datasource.password=legicycle
spring.second-datasource.driverClassName=org.postgresql.Driver

#these are grabbed by the datasource config for db2
spring.second-datasource.ddl=${SPRING_DATASOURCE_DDL:create-drop}
spring.second-datasource.dialect=org.hibernate.dialect.PostgreSQLDialect
